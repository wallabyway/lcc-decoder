<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LCC 3DGS Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; background: #0a0a0f; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { LCCLoader } from './lcc-loader.js';
        import { GaussianSplatRenderer } from './splat-renderer.js';

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1f);
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 10000);
        camera.up.set(0, 0, 1);
        camera.position.set(1.437, 0.830, 0.345);
        camera.rotation.set(-1.365, 0.719, 3.005);

        // First-person controls (Z-up)
        const euler = new THREE.Euler(0, 0, 0, 'ZXY');
        const PI_2 = Math.PI / 2;
        let isLocked = false;
        let moveF = false, moveB = false, moveL = false, moveR = false, moveU = false, moveD = false, running = false;
        const speed = 5.0, runMult = 2.5, sens = 0.002;

        document.addEventListener('mousemove', e => {
            if (!isLocked) return;
            euler.setFromQuaternion(camera.quaternion, 'ZXY');
            euler.z -= e.movementX * sens;
            euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x - e.movementY * sens));
            camera.quaternion.setFromEuler(euler);
        });

        renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());
        document.addEventListener('pointerlockchange', () => { isLocked = document.pointerLockElement === renderer.domElement; });

        document.addEventListener('keydown', e => {
            if (e.code === 'KeyW') moveF = true;
            if (e.code === 'KeyS') moveB = true;
            if (e.code === 'KeyA') moveL = true;
            if (e.code === 'KeyD') moveR = true;
            if (e.code === 'KeyQ') moveU = true;
            if (e.code === 'KeyE') moveD = true;
            if (e.code.startsWith('Shift')) running = true;
        });
        document.addEventListener('keyup', e => {
            if (e.code === 'KeyW') moveF = false;
            if (e.code === 'KeyS') moveB = false;
            if (e.code === 'KeyA') moveL = false;
            if (e.code === 'KeyD') moveR = false;
            if (e.code === 'KeyQ') moveU = false;
            if (e.code === 'KeyE') moveD = false;
            if (e.code.startsWith('Shift')) running = false;
        });

        // Splat renderer
        let splatRenderer = null;
        const loader = new LCCLoader({ targetLOD: 1 });

        async function loadLCC(basePath) {
            try {
                const data = await loader.load(basePath);
                if (splatRenderer) { scene.remove(splatRenderer.mesh); splatRenderer.dispose(); }
                splatRenderer = new GaussianSplatRenderer(renderer, camera);
                await splatRenderer.init(data);
                scene.add(splatRenderer.mesh);

                // Grid
                const bb = data.boundingBox;
                const sz = Math.ceil(Math.max(bb.max[0] - bb.min[0], bb.max[1] - bb.min[1]) * 1.5);
                const grid = new THREE.GridHelper(sz, Math.min(100, sz * 2), 0x666666, 0x333333);
                grid.rotation.x = PI_2;
                grid.position.z = bb.min[2] - 0.5;
                scene.add(grid);
            } catch (e) { console.error('Load failed:', e); }
        }

        // Animation
        const clock = new THREE.Clock();
        const mv = new THREE.Vector3(), fwd = new THREE.Vector3(), right = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            if (moveF || moveB || moveL || moveR || moveU || moveD) {
                const s = speed * (running ? runMult : 1) * dt;
                mv.set(0, 0, 0);
                camera.getWorldDirection(fwd);
                right.crossVectors(fwd, camera.up).normalize();
                fwd.z = 0; fwd.normalize();
                if (moveF) mv.addScaledVector(fwd, s);
                if (moveB) mv.addScaledVector(fwd, -s);
                if (moveR) mv.addScaledVector(right, s);
                if (moveL) mv.addScaledVector(right, -s);
                if (moveU) mv.z += s;
                if (moveD) mv.z -= s;
                camera.position.add(mv);
            }

            splatRenderer?.update(camera);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
            splatRenderer?.resize(innerWidth, innerHeight);
        });

        // Load from URL param or default
        const dataPath = new URLSearchParams(location.search).get('data');
        loadLCC(dataPath || 'https://da9i2vj1xvtoc.cloudfront.net/lcc-model/showroom+level+2/showroom2.lcc');
        animate();

        // Debug
        Object.assign(window, { loadLCC, THREE, camera, euler, splatRenderer: () => splatRenderer });
    </script>
</body>
</html>
